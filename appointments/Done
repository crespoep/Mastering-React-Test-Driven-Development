Capitulo 1: 
npm init, para crear iniciar

Instalar Jest:
$ npm install --save-dev jest

Instalar React: 
$ npm install --save react react-dom

React usa JSX, y necesitamos Babel para transpilarlo, pero Jest ya lo incluye asi que solo se necesitan algunos presets y plugins:
npm install --save-dev @babel/preset-env @babel/preset-react
npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime

Se agregan los presets en el archivo .babelrc
{
"presets": ["@babel/env", "@babel/react"],
"plugins": ["@babel/transform-runtime"]
}

Para empezar los tests:
All of the Jest functions are already required and available in the global
namespace when you run the npm test command. You don't need to
import anything.

Remember our principle: always implement the simplest thing that will possibly work.
That includes hard-coding, when it's possible. In order to get to the real implementation,
we need to add more tests. This process is called triangulation. The more specific our tests
get, the more general our production code needs to get.

The parts of a test that you want to see are the parts that differ between
tests. Usually, some data remains the same ( container in this example)
and some differs ( customer in this example). Do your best to hide away
whatever is the same and proudly display what differs.

In the test, the today constant is defined to be new Date() . Each of the two
records then uses this as a kind of "base" date to work its own time off.
Whenever we're dealing with dates, it's important that we base all events on
the same moment in time, rather than asking the system for the current time
more than once. Doing that is a subtle bug waiting to happen.

React components respond to what it calls synthetic events. React uses
these to mask browser discrepancies in the DOM event model. That
means we can't raise standard events that we'd fire through JSDOM.
Instead, we use the ReactTestUtils.Simulate object to raise events.

At this stage, I'm not too bothered about where the customer name
appears on screen. Testing container.textContent is like saying I want
this text to appear somewhere, but I don't care where. Later on, we'll see
techniques for expecting text in specific places.

Jest includes Babel, which transpiles all our code when it's run in the test environment. But
what about when we're serving our code via our website? Jest won't be able to help us
there.

We've given this form an ID and that our test looks specifically for that ID
in its expectation. This protects us from brittle tests. For example, if our
test just looked for any form, then it could break if we design our page to
include two forms rather than just this one.

TIP:
Al hacer un map de una variable que no le pasé, por ej selectableServices o customer, tira error de undefined

TIP:
cuando quiere buscar un elemento en el DOM con un selector y no existe, tira null
cuando busca un elemento dentro de un form con .elements y no existe, tira undefined, de ahí varía usar toBeNull() o toBeUndefined()

it('pre-selects the existing value', () => {
  const services = ['Cut', 'Blow-dry']
  render(
    <AppointmentForm
      selectableServices={services}
      service="Blow-dry"
    />
  )
  const option = findOption(
    field('service'),
    'Blow-dry'
  )
  expect(option.selected).toBeTruthy()
  // It could be also:
  // expect(field('service').value).toEqual('Blow-dry')
  // It seems more straightforward to me
})

TIP:
Ver bien como funciona useCallback
