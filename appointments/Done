Capitulo 1: 
npm init, para crear iniciar

Instalar Jest:
$ npm install --save-dev jest

Instalar React: 
$ npm install --save react react-dom

React usa JSX, y necesitamos Babel para transpilarlo, pero Jest ya lo incluye asi que solo se necesitan algunos presets y plugins:
npm install --save-dev @babel/preset-env @babel/preset-react
npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime

Se agregan los presets en el archivo .babelrc
{
"presets": ["@babel/env", "@babel/react"],
"plugins": ["@babel/transform-runtime"]
}

Para empezar los tests:
All of the Jest functions are already required and available in the global
namespace when you run the npm test command. You don't need to
import anything.

Remember our principle: always implement the simplest thing that will possibly work.
That includes hard-coding, when it's possible. In order to get to the real implementation,
we need to add more tests. This process is called triangulation. The more specific our tests
get, the more general our production code needs to get.

The parts of a test that you want to see are the parts that differ between
tests. Usually, some data remains the same ( container in this example)
and some differs ( customer in this example). Do your best to hide away
whatever is the same and proudly display what differs.

In the test, the today constant is defined to be new Date() . Each of the two
records then uses this as a kind of "base" date to work its own time off.
Whenever we're dealing with dates, it's important that we base all events on
the same moment in time, rather than asking the system for the current time
more than once. Doing that is a subtle bug waiting to happen.

React components respond to what it calls synthetic events. React uses
these to mask browser discrepancies in the DOM event model. That
means we can't raise standard events that we'd fire through JSDOM.
Instead, we use the ReactTestUtils.Simulate object to raise events.

At this stage, I'm not too bothered about where the customer name
appears on screen. Testing container.textContent is like saying I want
this text to appear somewhere, but I don't care where. Later on, we'll see
techniques for expecting text in specific places.